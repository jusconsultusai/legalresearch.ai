/**
 * Unified Search Orchestrator — JusConsultus AI
 *
 * Merges three complementary retrieval layers:
 *
 *   1. KAG  (Knowledge-Augmented Generation)
 *      └─ Logical form parsing → exact entity lookup → multi-hop graph traverse
 *         Strengths: Perfect for specific laws, G.R. numbers, citation chains
 *
 *   2. DeepSearcher (Vector + Agentic RAG)
 *      └─ Milvus Lite vector similarity + LLM sub-query decomposition
 *         Strengths: Semantic "find all cases about X" queries
 *
 *   3. Filesystem RAG (Keyword search)
 *      └─ Fast filename/content keyword matching across legal-database/
 *         Strengths: Broad coverage, always available, zero latency for typo-tolerant matches
 *
 * Selection strategy:
 *   "exact"    — query contains law/case numbers      → KAG first (50%), DS (30%), FS (20%)
 *   "research" — complex multi-concept query           → DS first (50%), KAG (30%), FS (20%)
 *   "quick"    — short query, no entities              → FS first (50%), KAG (25%), DS (25%)
 *   "agentic"  — mode=deep explicitly requested        → DS agentic pipeline exclusively
 *
 * Scoring weights (applied before final ranking):
 *   KAG exact_match   × 1.8
 *   KAG multi_hop     × 1.5
 *   DeepSearcher DS   × 1.3
 *   Filesystem RAG    × 1.0
 *
 * Public API:
 *   hybridSearch(query, options)  → UnifiedSearchResult
 *   buildUnifiedPrompt(result)    → string (LLM system prompt)
 */

import {
  kagSearch,
  buildKAGPrompt,
  parseLogicalForm,
  type KAGResult,
  type KAGSearchOptions,
} from "./kag";

import {
  isSidecarAvailable,
  vectorSearch,
  deepQuery,
  dsChunksToKAGResults,
  type DSQueryResponse,
} from "./deepsearcher-client";

import {
  searchFilesystemLegalDB,
  buildFilesystemRAGPrompt,
  type FileSystemRAGOptions,
} from "./rag-filesystem";

import type { RAGContext, RAGResult } from "./rag";

// ── Public types ──────────────────────────────────────────────────────────────

export interface UnifiedSearchOptions {
  /** Maximum number of final results to return */
  maxResults?: number;
  /** Source filters (category names to include) */
  sourceFilters?: string[];
  /** Enable KAG layer (default: true) */
  enableKAG?: boolean;
  /** Enable DeepSearcher vector layer (default: true, if sidecar available) */
  enableDeepSearcher?: boolean;
  /** Enable filesystem RAG layer (default: true) */
  enableFilesystem?: boolean;
  /** Override strategy selection */
  strategy?: "exact" | "research" | "quick" | "agentic" | "auto";
  /** Response mode for LLM prompt building */
  mode?: "standard_v2" | "concise" | "professional" | "educational" | "simple_english";
  /** Maximum wait time for KAG layer (ms) */
  kagTimeout?: number;
  /** Maximum wait time for DeepSearcher layer (ms) */
  dsTimeout?: number;
  /** Maximum wait time for Filesystem layer (ms) */
  fsTimeout?: number;
}

export interface UnifiedSearchResult {
  /** Merged ranked results */
  results: KAGResult[];
  /** Full context object for LLM synthesis */
  ragContext: RAGContext;
  /** The determined strategy used */
  strategy: "exact" | "research" | "quick" | "agentic";
  /** Whether each layer successfully returned results */
  layersUsed: {
    kag:          boolean;
    deepSearcher: boolean;
    filesystem:   boolean;
  };
  /** If DeepSearcher agentic mode was used, the full synthesis */
  agenticAnswer?: string;
  /** Sub-queries generated by DeepSearcher */
  subQueries?: string[];
  /** Debug timing info */
  timing?: {
    kag?:          number;
    deepSearcher?: number;
    filesystem?:   number;
    total:         number;
  };
}

// ── Score weights ─────────────────────────────────────────────────────────────

const SCORE_WEIGHTS: Record<KAGResult["retrievalMode"], number> = {
  exact_match:       1.8,
  entity_expansion:  1.6,
  multi_hop:         1.5,
  schema_lookup:     1.1,
  vector_fallback:   1.3,
};

// ── Strategy selection ────────────────────────────────────────────────────────

function selectStrategy(
  query:       string,
  override?:   UnifiedSearchOptions["strategy"]
): "exact" | "research" | "quick" | "agentic" {
  if (override && override !== "auto") return override;

  const logicalForm = parseLogicalForm(query);

  // Has specific law/case numbers → exact lookup wins
  if (logicalForm.entities.length > 0) return "exact";

  // Long complex research query
  const wordCount = query.trim().split(/\s+/).length;
  if (
    wordCount >= 8 ||
    logicalForm.requiresMultiHop ||
    ["explain_concept", "compare_laws", "general_research"].includes(logicalForm.intent)
  ) {
    return "research";
  }

  return "quick";
}

// ── Promise with timeout helper ───────────────────────────────────────────────

function withTimeout<T>(
  promise:   Promise<T>,
  timeoutMs: number,
  label:     string,
  fallback:  T
): Promise<T> {
  const timer = new Promise<T>((resolve) =>
    setTimeout(() => {
      console.warn(`[unified-search] ${label} timed out after ${timeoutMs}ms`);
      resolve(fallback);
    }, timeoutMs)
  );
  return Promise.race([promise, timer]);
}

// ── Layer runners ─────────────────────────────────────────────────────────────

async function runKAGLayer(
  query:     string,
  options:   KAGSearchOptions & { timeout?: number }
): Promise<KAGResult[]> {
  const result = await withTimeout(
    kagSearch(query, options),
    options.timeout || 15_000,
    "KAG",
    { ragContext: { query, results: [], totalResults: 0 }, logicalForm: parseLogicalForm(query), kagResults: [], retrievalModes: [] }
  );
  return result.kagResults;
}

async function runDeepSearcherLayer(
  query:    string,
  strategy: "exact" | "research" | "quick" | "agentic",
  options:  { maxResults?: number; timeout?: number }
): Promise<{ results: KAGResult[]; agenticAnswer?: string; subQueries?: string[] }> {
  const available = await isSidecarAvailable().catch(() => false);
  if (!available) {
    console.info("[unified-search] DeepSearcher sidecar unavailable — skipping DS layer");
    return { results: [] };
  }

  if (strategy === "agentic") {
    // Full agentic pipeline: sub-query decomposition + LLM synthesis
    const response = await withTimeout<DSQueryResponse | null>(
      deepQuery(query, 3, options.maxResults || 10),
      options.timeout || 60_000,
      "DeepSearcher/agentic",
      null
    );
    if (!response) return { results: [] };

    return {
      results:        dsChunksToKAGResults(response.sources, "vector_fallback"),
      agenticAnswer:  response.answer,
      subQueries:     response.sub_queries,
    };
  }

  // Fast vector search for non-agentic strategies
  const response = await withTimeout(
    vectorSearch(query, options.maxResults || 8),
    options.timeout || 15_000,
    "DeepSearcher/vector",
    null
  );
  if (!response) return { results: [] };

  return {
    results: dsChunksToKAGResults(response.results, "vector_fallback"),
  };
}

async function runFilesystemLayer(
  query:   string,
  options: FileSystemRAGOptions & { timeout?: number }
): Promise<KAGResult[]> {
  const fsContext = await withTimeout<RAGContext | null>(
    searchFilesystemLegalDB(query, { sourceFilters: options.sourceFilters, limit: options.limit }),
    options.timeout || 10_000,
    "Filesystem",
    null
  );
  if (!fsContext) return [];

  // Convert RAGResult → KAGResult (add missing KAG fields)
  return fsContext.results.map(
    (r): KAGResult => ({
      ...r,
      retrievalMode: "vector_fallback" as const,
      hopDepth:      0,
      reasoningChain: ["Filesystem keyword search"],
    })
  );
}

// ── Merge and rank results ────────────────────────────────────────────────────

function mergeAndRank(
  kag:        KAGResult[],
  dsResults:  KAGResult[],
  fsResults:  KAGResult[],
  maxResults: number
): KAGResult[] {
  const seen = new Map<string, KAGResult & { _weighted: number }>();

  const processResults = (results: KAGResult[]) => {
    for (const r of results) {
      const weight = SCORE_WEIGHTS[r.retrievalMode] ?? 1.0;
      const weighted = r.score * weight;
      const existing = seen.get(r.documentId);
      if (!existing || weighted > existing._weighted) {
        seen.set(r.documentId, { ...r, _weighted: weighted });
      }
    }
  };

  processResults(kag);
  processResults(dsResults);
  processResults(fsResults);

  const sorted = [...seen.values()].sort((a, b) => b._weighted - a._weighted);
  return sorted.slice(0, maxResults).map(({ _weighted: _, ...rest }) => rest as KAGResult);
}

// ── Main orchestrator ─────────────────────────────────────────────────────────

/**
 * hybridSearch — Main entry point for all AI feature routes.
 *
 * Example:
 *   const result = await hybridSearch("What does RA 9262 say about psychological violence?");
 *   const prompt  = buildUnifiedPrompt(result);
 *   // pass prompt to LLM generateCompletion()
 */
export async function hybridSearch(
  query:   string,
  options: UnifiedSearchOptions = {}
): Promise<UnifiedSearchResult> {
  const startTime = Date.now();

  const {
    maxResults     = 12,
    enableKAG      = true,
    enableDeepSearcher = true,
    enableFilesystem   = true,
    strategy:      strategyOverride,
    kagTimeout        = 15_000,
    dsTimeout         = 20_000,
    fsTimeout         = 10_000,
    sourceFilters,
  } = options;

  const strategy = selectStrategy(query, strategyOverride);

  // ── Allocate result budgets per strategy ──────────────────────────────────
  const budgets = {
    exact:    { kag: 8, ds: 4, fs: 3 },
    research: { kag: 5, ds: 8, fs: 4 },
    quick:    { kag: 4, ds: 4, fs: 8 },
    agentic:  { kag: 0, ds: 12, fs: 0 },
  }[strategy];

  // ── Timing tracking ───────────────────────────────────────────────────────
  const timing: UnifiedSearchResult["timing"] = { total: 0 };

  // ── Run enabled layers in parallel ───────────────────────────────────────
  const layerPromises: [
    Promise<KAGResult[]>,
    Promise<{ results: KAGResult[]; agenticAnswer?: string; subQueries?: string[] }>,
    Promise<KAGResult[]>
  ] = [
    enableKAG && strategy !== "agentic"
      ? (async () => {
          const t = Date.now();
          const r = await runKAGLayer(query, {
            maxResults:             budgets.kag,
            enableMultiHop:         strategy === "exact" || strategy === "research",
            graphTraversalDepth:    strategy === "exact" ? 1 : 0,
            sourceFilters,
            timeout:                kagTimeout,
          });
          timing.kag = Date.now() - t;
          return r;
        })()
      : Promise.resolve([]),

    enableDeepSearcher
      ? (async () => {
          const t = Date.now();
          const r = await runDeepSearcherLayer(query, strategy, {
            maxResults: budgets.ds,
            timeout:    dsTimeout,
          });
          timing.deepSearcher = Date.now() - t;
          return r;
        })()
      : Promise.resolve({ results: [] }),

    enableFilesystem && strategy !== "agentic"
      ? (async () => {
          const t = Date.now();
          const r = await runFilesystemLayer(query, {
            limit:         budgets.fs,
            sourceFilters,
            timeout:       fsTimeout,
          });
          timing.filesystem = Date.now() - t;
          return r;
        })()
      : Promise.resolve([]),
  ];

  const [kagResults, dsOutput, fsResults] = await Promise.all(layerPromises);

  timing.total = Date.now() - startTime;

  // ── Merge and rank ────────────────────────────────────────────────────────
  const merged = mergeAndRank(kagResults, dsOutput.results, fsResults, maxResults);

  const ragContext: RAGContext = {
    query,
    results:      merged,
    totalResults: merged.length,
  };

  return {
    results:       merged,
    ragContext,
    strategy,
    layersUsed: {
      kag:          kagResults.length > 0,
      deepSearcher: dsOutput.results.length > 0,
      filesystem:   fsResults.length > 0,
    },
    agenticAnswer: dsOutput.agenticAnswer,
    subQueries:    dsOutput.subQueries,
    timing,
  };
}

// ── Prompt builder ─────────────────────────────────────────────────────────────

/**
 * Build a unified LLM system prompt from the hybrid search result.
 * Routes to KAG prompt builder (which includes logical form + entity graph).
 */
export function buildUnifiedPrompt(
  searchResult: UnifiedSearchResult,
  mode: UnifiedSearchOptions["mode"] = "standard_v2"
): string {
  const { agenticAnswer, subQueries, ragContext, strategy, layersUsed, timing } = searchResult;

  // For agentic strategy: prepend the DS-synthesized answer as grounding context
  if (strategy === "agentic" && agenticAnswer) {
    const sourcesSection = ragContext.results
      .map((r, i) => `[${i + 1}] ${r.title}${r.date ? ` (${r.date})` : ""}\n${r.relevantText || ""}`)
      .join("\n\n---\n\n");

    return `You are JusConsultus AI, an expert Philippine legal research assistant.

A deep-search pipeline has already analyzed this query by decomposing it into sub-questions and synthesizing an answer from the legal database.

SUB-QUESTIONS EXPLORED:
${subQueries?.map((q, i) => `${i + 1}. ${q}`).join("\n") || "(none)"}

INITIAL SYNTHESIS (from semantic search):
${agenticAnswer}

SUPPORTING SOURCES:
${sourcesSection || "No specific documents were retrieved. Supplement with your comprehensive knowledge of Philippine law."}

Your task: Refine and improve the synthesis above. Verify facts against the sources, add specific citations, and improve clarity. If the synthesis contains errors or gaps, correct them using your knowledge of Philippine law. Always provide a complete, helpful answer — never refuse to answer or say the information is unavailable. Provide your answer in structured Philippine legal writing format with explicit citations.
`;
  }

  // Standard: use KAG prompt builder
  const logicalForm = parseLogicalForm(searchResult.ragContext.query);

  const debugFooter =
    process.env.NODE_ENV === "development"
      ? `\n\n<!-- [unified-search] strategy=${strategy} layers=${Object.entries(layersUsed).filter(([, v]) => v).map(([k]) => k).join("+")} timing=${JSON.stringify(timing)} -->`
      : "";

  return buildKAGPrompt(ragContext, logicalForm, mode) + debugFooter;
}

/**
 * Convenience wrapper: run hybrid search and return full prompt string ready
 * to pass as the `system` message to generateCompletion() or the LLM client.
 */
export async function searchAndBuildPrompt(
  query:   string,
  options: UnifiedSearchOptions = {}
): Promise<{ prompt: string; searchResult: UnifiedSearchResult }> {
  const searchResult = await hybridSearch(query, options);
  const prompt = buildUnifiedPrompt(searchResult, options.mode);
  return { prompt, searchResult };
}
